import * as React from 'react'
import { render, screen, act, waitFor } from '@testing-library/react'
import { axe } from 'jest-axe'
import userEvent from '@testing-library/user-event'
import { Tooltip, SHOW_DELAY, HIDE_DELAY } from './tooltip'
import { flushPromises } from '../utils/test-helpers'
import { Box } from '../box'
import { Button } from '../button'

// Runs the same test abstracting how the tooltip is triggered (can be via mouse or keyboard)
async function testShowHide({
    triggerShow,
    triggerHide,
}: {
    triggerShow: () => void
    triggerHide: () => void
}) {
    triggerShow()

    // tooltip is not immediately visible
    expect(screen.queryByRole('tooltip')).not.toBeInTheDocument()
    // wait a bit
    await act(() => {
        jest.advanceTimersByTime(SHOW_DELAY)
        return flushPromises()
    })
    // tooltip is now visible
    expect(screen.getByRole('tooltip', { name: 'tooltip content here' })).toBeInTheDocument()

    triggerHide()

    // tooltip is not immediately removed
    expect(screen.getByRole('tooltip', { name: 'tooltip content here' })).toBeInTheDocument()
    // wait a bit
    act(() => {
        jest.advanceTimersByTime(HIDE_DELAY)
    })
    // tooltip is gone
    expect(screen.queryByRole('tooltip')).not.toBeInTheDocument()
}

describe('Tooltip', () => {
    beforeEach(() => {
        jest.useFakeTimers()
    })
    afterEach(() => {
        jest.useRealTimers()
    })

    it('renders a tooltip when the button gets focus, hides it when blurred', async () => {
        render(
            <Tooltip content="tooltip content here">
                <button>Click me</button>
            </Tooltip>,
        )
        const button = screen.getByRole('button', { name: 'Click me' })

        await testShowHide({
            triggerShow() {
                userEvent.tab()
                expect(button).toHaveFocus()
            },
            triggerHide() {
                userEvent.tab()
            },
        })
    })

    // Calls into testShowHide subtest.
    // eslint-disable-next-line jest/expect-expect
    it('renders a tooltip when the button is hovered, hides it when unhovered', async () => {
        render(
            <Tooltip content="tooltip content here">
                <button>Click me</button>
            </Tooltip>,
        )
        const button = screen.getByRole('button', { name: 'Click me' })
        await testShowHide({
            triggerShow() {
                userEvent.hover(button)
            },
            triggerHide() {
                userEvent.unhover(button)
            },
        })
    })

    it('does not render a tooltip if the content is empty', async () => {
        render(
            <Tooltip content={null}>
                <button>Click me</button>
            </Tooltip>,
        )
        const button = screen.getByRole('button', { name: 'Click me' })

        // mouse over and wait more than enough
        userEvent.hover(button)
        act(() => {
            jest.advanceTimersByTime(SHOW_DELAY * 2)
        })
        expect(screen.queryByRole('tooltip')).not.toBeInTheDocument()

        // focus on button and wait more than enough
        userEvent.tab()
        expect(button).toHaveFocus()
        await act(() => {
            jest.advanceTimersByTime(SHOW_DELAY * 2)
            // Ariakit performs state changes asynchronously that needs to be flushed
            return Promise.resolve()
        })

        expect(screen.queryByRole('tooltip')).not.toBeInTheDocument()
    })

    it('does not render the tooltip markup at all while not shown', () => {
        render(
            <Tooltip content="tooltip content here">
                <button>Click me</button>
            </Tooltip>,
        )
        // queryByText, unlike getByRole, will find an element even if hidden with display: none or
        // by any other means. getByRole on the other hand takes visibility into account.
        expect(screen.queryByText('tooltip content here')).not.toBeInTheDocument()
    })

    it('can render content generated by a function only called when needed', async () => {
        const content = jest.fn(() => 'tooltip content generated dynamically')
        render(
            <Tooltip content={content}>
                <button>Click me</button>
            </Tooltip>,
        )
        const button = screen.getByRole('button', { name: 'Click me' })

        // assert that content has not been generated internally even, not even after a delay
        act(() => {
            jest.advanceTimersByTime(SHOW_DELAY * 2)
        })
        expect(content).not.toHaveBeenCalled()

        // content is generated when the tooltip is needed to be shown
        userEvent.hover(button)
        act(() => {
            jest.advanceTimersByTime(SHOW_DELAY)
        })

        // Ariakit performs state changes asynchronously that needs to be flushed
        await flushPromises()

        expect(content).toHaveBeenCalled()
    })

    /**
     * @see https://github.com/ariakit/ariakit/discussions/749
     */
    it('does not show the tooltip if the button received focus in a way not associated with a key event', () => {
        function getTooltipButton() {
            return screen.getByRole('button', { name: 'Click me' })
        }

        render(
            <>
                <Tooltip content="tooltip content here">
                    <button>Click me</button>
                </Tooltip>
                <button onClick={() => getTooltipButton().focus()}>Trigger focus</button>
            </>,
        )

        userEvent.click(screen.getByRole('button', { name: 'Trigger focus' }))
        expect(getTooltipButton()).toHaveFocus()

        act(() => {
            jest.advanceTimersByTime(SHOW_DELAY * 2)
        })
        expect(screen.queryByRole('tooltip')).not.toBeInTheDocument()
    })

    it("does not interfere with the trigger element's ref forwarding", () => {
        const buttonRef = React.createRef<HTMLButtonElement>()

        render(
            <Tooltip content="tooltip content here">
                <button ref={buttonRef}>Click me</button>
            </Tooltip>,
        )

        expect(buttonRef.current).toBe(screen.getByRole('button'))
    })

    it('supports components with an "as" prop as the anchor', async () => {
        render(
            <Tooltip content="tooltip content here">
                <Box as={Button} variant="primary">
                    Click me
                </Box>
            </Tooltip>,
        )

        const button = screen.getByRole('button', { name: 'Click me' })
        expect(button).toBeVisible()

        await testShowHide({
            triggerShow() {
                userEvent.hover(button)
            },
            triggerHide() {
                userEvent.unhover(button)
            },
        })
    })

    describe('a11y', () => {
        it('renders with no a11y violations', async () => {
            const { container } = render(
                <Tooltip content="tooltip content here">
                    <button>Click me</button>
                </Tooltip>,
            )

            const button = screen.getByRole('button', { name: 'Click me' })
            userEvent.hover(button)

            act(() => {
                jest.advanceTimersByTime(SHOW_DELAY * 2)
            })

            // Ariakit performs state changes asynchronously that needs to be flushed
            await flushPromises()

            jest.useRealTimers()

            const results = await axe(container)
            expect(results).toHaveNoViolations()
        })
    })

    it('sets the tooltip content as the trigger element’s accessible description', async () => {
        render(
            <Tooltip content="tooltip content here">
                <button>Click me</button>
            </Tooltip>,
        )

        // Since the content is only rendered when the tooltip appears, this description is only
        // available when we hover or focus the button, and not before.
        const button = screen.getByRole('button', { name: 'Click me' })
        userEvent.tab()

        await waitFor(
            () => {
                expect(button).toHaveAccessibleDescription('tooltip content here')
            },
            { timeout: SHOW_DELAY + 10 },
        )
    })

    it('does not acknowledge the className prop, but exceptionallySetClassName instead', async () => {
        render(
            <Tooltip
                content="I’m a tooltip"
                // @ts-expect-error
                className="wrong"
                exceptionallySetClassName="right"
            >
                <button>Click me</button>
            </Tooltip>,
        )
        // Since the content is only rendered when the tooltip appears, this description is only
        // available when we hover or focus the button, and not before.
        userEvent.tab()

        const tooltip = await screen.findByRole(
            'tooltip',
            { name: 'I’m a tooltip' },
            { timeout: SHOW_DELAY + 10 },
        )
        expect(tooltip).toHaveClass('right')
        expect(tooltip).not.toHaveClass('wrong')
    })
})
